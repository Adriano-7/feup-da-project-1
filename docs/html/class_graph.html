<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Railway Network Management System: Graph Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Railway Network Management System
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_graph-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Graph Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Class that represents a graph. Contains a map of nodes, where the key is the station name. Each node has a set of edges.  
 <a href="class_graph.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_graph_8h_source.html">Graph.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0da59714ff8914a1762adf160c72aa0e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a0da59714ff8914a1762adf160c72aa0e">addNode</a> (<a class="el" href="class_station.html">Station</a> &amp;station)</td></tr>
<tr class="memdesc:a0da59714ff8914a1762adf160c72aa0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a node to the graph.  <br /></td></tr>
<tr class="separator:a0da59714ff8914a1762adf160c72aa0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc74e5bbc17e50c26b3698061c715c9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a5bc74e5bbc17e50c26b3698061c715c9">addEdge</a> (<a class="el" href="class_node.html">Node</a> *source, <a class="el" href="class_node.html">Node</a> *dest, int capacity, ServiceType service)</td></tr>
<tr class="memdesc:a5bc74e5bbc17e50c26b3698061c715c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a unidirectional edge to the graph.  <br /></td></tr>
<tr class="separator:a5bc74e5bbc17e50c26b3698061c715c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cc85821bda80afe8517d4699f2cacd0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a3cc85821bda80afe8517d4699f2cacd0">addBidirectionalEdge</a> (<a class="el" href="class_node.html">Node</a> *sourceNode, <a class="el" href="class_node.html">Node</a> *destNode, int capacity, ServiceType service)</td></tr>
<tr class="memdesc:a3cc85821bda80afe8517d4699f2cacd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a Bidirectional <a class="el" href="class_edge.html" title="Represents an edge in the graph. Contains a destination node, a capacity, a service type and a flow.">Edge</a> to the graph.  <br /></td></tr>
<tr class="separator:a3cc85821bda80afe8517d4699f2cacd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f411aaa3c247488d42550d8dfd7553"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ac4f411aaa3c247488d42550d8dfd7553">eraseNode</a> (<a class="el" href="class_node.html">Node</a> *node)</td></tr>
<tr class="memdesc:ac4f411aaa3c247488d42550d8dfd7553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a node from the graph.  <br /></td></tr>
<tr class="separator:ac4f411aaa3c247488d42550d8dfd7553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4909a9f294f6f1af573d21f85fb1ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#afb4909a9f294f6f1af573d21f85fb1ab">getNode</a> (string stationName)</td></tr>
<tr class="memdesc:afb4909a9f294f6f1af573d21f85fb1ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the name of a station, returns the node associated with it.  <br /></td></tr>
<tr class="separator:afb4909a9f294f6f1af573d21f85fb1ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23825eeba3e8fbb811d4e1b67042e97f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a23825eeba3e8fbb811d4e1b67042e97f">getNode</a> (<a class="el" href="class_station.html">Station</a> *station)</td></tr>
<tr class="memdesc:a23825eeba3e8fbb811d4e1b67042e97f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a station, returns the node associated with it.  <br /></td></tr>
<tr class="separator:a23825eeba3e8fbb811d4e1b67042e97f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa93f64130d4c6ee4656a4f77457ca3fa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#aa93f64130d4c6ee4656a4f77457ca3fa">bfs</a> (<a class="el" href="class_node.html">Node</a> *source, <a class="el" href="class_node.html">Node</a> *dest)</td></tr>
<tr class="memdesc:aa93f64130d4c6ee4656a4f77457ca3fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds paths between the source and the destination.  <br /></td></tr>
<tr class="separator:aa93f64130d4c6ee4656a4f77457ca3fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7e5157dcba34abbe92a3c06b905eefb"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ac7e5157dcba34abbe92a3c06b905eefb">dijkstra</a> (<a class="el" href="class_node.html">Node</a> *source, <a class="el" href="class_node.html">Node</a> *dest)</td></tr>
<tr class="memdesc:ac7e5157dcba34abbe92a3c06b905eefb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the shortest path between the source and the destination using the cost of the service (and the capacity).  <br /></td></tr>
<tr class="separator:ac7e5157dcba34abbe92a3c06b905eefb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af6a3a2293f47efb5b9d02adb16014a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a9af6a3a2293f47efb5b9d02adb16014a">EdmondsKarp</a> (<a class="el" href="class_node.html">Node</a> *source, <a class="el" href="class_node.html">Node</a> *dest)</td></tr>
<tr class="memdesc:a9af6a3a2293f47efb5b9d02adb16014a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edmonds Karp - Finds the maximum flow in the network flow graph.  <br /></td></tr>
<tr class="separator:a9af6a3a2293f47efb5b9d02adb16014a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43eca8ca3513afdbcfe5f0e73629678b"><td class="memItemLeft" align="right" valign="top">stack&lt; <a class="el" href="class_edge.html">Edge</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a43eca8ca3513afdbcfe5f0e73629678b">BottleneckDijkstra</a> (<a class="el" href="class_node.html">Node</a> *source, <a class="el" href="class_node.html">Node</a> *dest, double *flow, double *costService)</td></tr>
<tr class="memdesc:a43eca8ca3513afdbcfe5f0e73629678b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the Dijkstra algorithm to find the shortest path (cost of service) and then calculates the bottleneck flow.  <br /></td></tr>
<tr class="separator:a43eca8ca3513afdbcfe5f0e73629678b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa6a52e1f06afe31061695fb294d005"><td class="memItemLeft" align="right" valign="top">vector&lt; pair&lt; <a class="el" href="class_node.html">Node</a> *, <a class="el" href="class_node.html">Node</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a1aa6a52e1f06afe31061695fb294d005">maxFlowAllPairs</a> (int *max_flow)</td></tr>
<tr class="memdesc:a1aa6a52e1f06afe31061695fb294d005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates through all pairs of nodes in the network and uses the Edmonds Karp algorithm to find the maximum flow between them.  <br /></td></tr>
<tr class="separator:a1aa6a52e1f06afe31061695fb294d005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0280d09e3878357672dcfac7a3f9835"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ab0280d09e3878357672dcfac7a3f9835">sumSomePairsFlow</a> (set&lt; <a class="el" href="class_node.html">Node</a> * &gt; nodes, int *sumFlow)</td></tr>
<tr class="memdesc:ab0280d09e3878357672dcfac7a3f9835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the sum of the maximum flows between all pairs of nodes in the input set.  <br /></td></tr>
<tr class="separator:ab0280d09e3878357672dcfac7a3f9835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1284d28d6a656e876188f5f8f4cf2263"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a1284d28d6a656e876188f5f8f4cf2263">maxIncomingFlow</a> (<a class="el" href="class_node.html">Node</a> *node)</td></tr>
<tr class="memdesc:a1284d28d6a656e876188f5f8f4cf2263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the maximum incoming flow to the input node.  <br /></td></tr>
<tr class="separator:a1284d28d6a656e876188f5f8f4cf2263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4762ccdb8e3f00e183e8eacb6f9c47cf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a4762ccdb8e3f00e183e8eacb6f9c47cf">checkConnection</a> (<a class="el" href="class_node.html">Node</a> *source, <a class="el" href="class_node.html">Node</a> *dest, int &amp;edgeCapacity)</td></tr>
<tr class="memdesc:a4762ccdb8e3f00e183e8eacb6f9c47cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two nodes are adjacent.  <br /></td></tr>
<tr class="separator:a4762ccdb8e3f00e183e8eacb6f9c47cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f04f528f54777e5559221cb22dbe62b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a1f04f528f54777e5559221cb22dbe62b">changeCapacity</a> (<a class="el" href="class_node.html">Node</a> *source, <a class="el" href="class_node.html">Node</a> *dest, int newCapacity)</td></tr>
<tr class="memdesc:a1f04f528f54777e5559221cb22dbe62b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the capacity of an edge.  <br /></td></tr>
<tr class="separator:a1f04f528f54777e5559221cb22dbe62b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class that represents a graph. Contains a map of nodes, where the key is the station name. Each node has a set of edges. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a3cc85821bda80afe8517d4699f2cacd0" name="a3cc85821bda80afe8517d4699f2cacd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cc85821bda80afe8517d4699f2cacd0">&#9670;&#160;</a></span>addBidirectionalEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::addBidirectionalEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>sourceNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>destNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ServiceType&#160;</td>
          <td class="paramname"><em>service</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a Bidirectional <a class="el" href="class_edge.html" title="Represents an edge in the graph. Contains a destination node, a capacity, a service type and a flow.">Edge</a> to the graph. </p>
<p>Time Complexity: O(1) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceNode</td><td>- The source node. </td></tr>
    <tr><td class="paramname">destNode</td><td>- The destination node. </td></tr>
    <tr><td class="paramname">capacity</td><td>- Number of trains that can pass through the edge.r </td></tr>
    <tr><td class="paramname">service</td><td>- Which can be either Standard or AlfaPendular </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a5bc74e5bbc17e50c26b3698061c715c9" name="a5bc74e5bbc17e50c26b3698061c715c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bc74e5bbc17e50c26b3698061c715c9">&#9670;&#160;</a></span>addEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::addEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>sourceNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>destNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ServiceType&#160;</td>
          <td class="paramname"><em>service</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a unidirectional edge to the graph. </p>
<p>Time Complexity: O(1) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceNode</td><td>- The source node. </td></tr>
    <tr><td class="paramname">destNode</td><td>- The destination node. </td></tr>
    <tr><td class="paramname">capacity</td><td>- Number of trains that can pass through the edge.r </td></tr>
    <tr><td class="paramname">service</td><td>- Which can be either Standard or AlfaPendular </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the edge was added successfully, false otherwise. </dd></dl>

</div>
</div>
<a id="a0da59714ff8914a1762adf160c72aa0e" name="a0da59714ff8914a1762adf160c72aa0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0da59714ff8914a1762adf160c72aa0e">&#9670;&#160;</a></span>addNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::addNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_station.html">Station</a> &amp;&#160;</td>
          <td class="paramname"><em>station</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a node to the graph. </p>
<p>Time Complexity: O(log n), where n is the number of nodes in the graph. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">station</td><td>- The station of the node to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the node was added successfully, false otherwise. </dd></dl>

</div>
</div>
<a id="aa93f64130d4c6ee4656a4f77457ca3fa" name="aa93f64130d4c6ee4656a4f77457ca3fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa93f64130d4c6ee4656a4f77457ca3fa">&#9670;&#160;</a></span>bfs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::bfs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds paths between the source and the destination. </p>
<p>Time Complexity: O(E+V), where E is the number of edges and V is the number of nodes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>- The source node. </td></tr>
    <tr><td class="paramname">dest</td><td>- The destination node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if there is a path between the source and the destination, false otherwise. </dd></dl>

</div>
</div>
<a id="a43eca8ca3513afdbcfe5f0e73629678b" name="a43eca8ca3513afdbcfe5f0e73629678b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43eca8ca3513afdbcfe5f0e73629678b">&#9670;&#160;</a></span>BottleneckDijkstra()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">stack&lt; <a class="el" href="class_edge.html">Edge</a> * &gt; Graph::BottleneckDijkstra </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>flow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>costService</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses the Dijkstra algorithm to find the shortest path (cost of service) and then calculates the bottleneck flow. </p>
<p>Time Complexity: O((V+E log V), where E is the number of edges and V is the number of nodes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>- Source node </td></tr>
    <tr><td class="paramname">dest</td><td>- Destination node </td></tr>
    <tr><td class="paramname">flow</td><td>- Pointer to that will be filled with the bottleneck flow </td></tr>
    <tr><td class="paramname">costService</td><td>- Pointer to that will be filled with the cost of the service </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Stack with the edges of the path. </dd></dl>

</div>
</div>
<a id="a1f04f528f54777e5559221cb22dbe62b" name="a1f04f528f54777e5559221cb22dbe62b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f04f528f54777e5559221cb22dbe62b">&#9670;&#160;</a></span>changeCapacity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::changeCapacity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newCapacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the capacity of an edge. </p>
<p>Time Complexity: O(E), where E is the number of adjacent edges. Changes the capacity of the edges between two nodes with the new capacity. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>- Source node of the edge. </td></tr>
    <tr><td class="paramname">dest</td><td>- Destination node of the edge. </td></tr>
    <tr><td class="paramname">newCapacity</td><td>- New capacity of the edge. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4762ccdb8e3f00e183e8eacb6f9c47cf" name="a4762ccdb8e3f00e183e8eacb6f9c47cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4762ccdb8e3f00e183e8eacb6f9c47cf">&#9670;&#160;</a></span>checkConnection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::checkConnection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>edgeCapacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if two nodes are adjacent. </p>
<p>Time Complexity: O(E), where E is the number of adjacent edges. Checks if two nodes are adjacent, given the source and destination nodes of the edge. And updates the var edgeCapacity with the capacity of the edge. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>- Source node of the edge. </td></tr>
    <tr><td class="paramname">dest</td><td>- Destination node of the edge. </td></tr>
    <tr><td class="paramname">edgeCapacity</td><td>- Pointer to the variable that will store the capacity of the edge. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the nodes are adjacent, false otherwise. </dd></dl>

</div>
</div>
<a id="ac7e5157dcba34abbe92a3c06b905eefb" name="ac7e5157dcba34abbe92a3c06b905eefb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7e5157dcba34abbe92a3c06b905eefb">&#9670;&#160;</a></span>dijkstra()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Graph::dijkstra </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the shortest path between the source and the destination using the cost of the service (and the capacity). </p>
<p>Time Complexity: O((V+E log V), where E is the number of edges and V is the number of nodes. Taking into account the cost of Service and the number of trains that can pass through the edge finds the shortest path between the source and the destination. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>- The source node. </td></tr>
    <tr><td class="paramname">dest</td><td>- The destination node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cost of the path. </dd></dl>

</div>
</div>
<a id="a9af6a3a2293f47efb5b9d02adb16014a" name="a9af6a3a2293f47efb5b9d02adb16014a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9af6a3a2293f47efb5b9d02adb16014a">&#9670;&#160;</a></span>EdmondsKarp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Graph::EdmondsKarp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Edmonds Karp - Finds the maximum flow in the network flow graph. </p>
<p>Time Complexity: O(VE^2), where E is the number of edges and V is the number of nodes. Using BFS finds the maximum flow in the network flow graph between the source and the destination. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>- Source node </td></tr>
    <tr><td class="paramname">dest</td><td>- Destination node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum flow. </dd></dl>

</div>
</div>
<a id="ac4f411aaa3c247488d42550d8dfd7553" name="ac4f411aaa3c247488d42550d8dfd7553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4f411aaa3c247488d42550d8dfd7553">&#9670;&#160;</a></span>eraseNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::eraseNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a node from the graph. </p>
<p>Time Complexity: O(E+I), where E is the number of outgoing edges and I is the number of incoming edges. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>- The node to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the node was removed successfully, false otherwise. </dd></dl>

</div>
</div>
<a id="a23825eeba3e8fbb811d4e1b67042e97f" name="a23825eeba3e8fbb811d4e1b67042e97f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23825eeba3e8fbb811d4e1b67042e97f">&#9670;&#160;</a></span>getNode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_node.html">Node</a> * Graph::getNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_station.html">Station</a> *&#160;</td>
          <td class="paramname"><em>station</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a station, returns the node associated with it. </p>
<p>Time Complexity: O(log n), where n is the number of nodes in the graph. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">station</td><td>- A pointer to the station. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the node associated with the station, nullptr if the station does not exist. </dd></dl>

</div>
</div>
<a id="afb4909a9f294f6f1af573d21f85fb1ab" name="afb4909a9f294f6f1af573d21f85fb1ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb4909a9f294f6f1af573d21f85fb1ab">&#9670;&#160;</a></span>getNode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_node.html">Node</a> * Graph::getNode </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>stationName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the name of a station, returns the node associated with it. </p>
<p>Time Complexity: O(log n), where n is the number of nodes in the graph. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stationName</td><td>- The name of the station. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the node associated with the station, nullptr if the station does not exist. </dd></dl>

</div>
</div>
<a id="a1aa6a52e1f06afe31061695fb294d005" name="a1aa6a52e1f06afe31061695fb294d005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aa6a52e1f06afe31061695fb294d005">&#9670;&#160;</a></span>maxFlowAllPairs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; pair&lt; <a class="el" href="class_node.html">Node</a> *, <a class="el" href="class_node.html">Node</a> * &gt; &gt; Graph::maxFlowAllPairs </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>maxFlow</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterates through all pairs of nodes in the network and uses the Edmonds Karp algorithm to find the maximum flow between them. </p>
<p>Time Complexity: O(V^3E^2), where E is the number of edges and V is the number of nodes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxFlow</td><td>- Pointer to the variable that will store the maximum flow. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector with the pairs of nodes that have the maximum flow. </dd></dl>

</div>
</div>
<a id="a1284d28d6a656e876188f5f8f4cf2263" name="a1284d28d6a656e876188f5f8f4cf2263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1284d28d6a656e876188f5f8f4cf2263">&#9670;&#160;</a></span>maxIncomingFlow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Graph::maxIncomingFlow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the maximum incoming flow to the input node. </p>
<p>Time Complexity: O(V E^2), where E is the number of edges and V is the number of nodes. Creates a super source node and connects it to all nodes that have only one outgoing edge. Then uses the Edmonds Karp algorithm to find the maximum flow between the super source and the input node. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>- <a class="el" href="class_node.html" title="Represents a node in the graph. Contains a station and a vector of adjacent edges.">Node</a> to calculate the maximum incoming flow. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum incoming flow to the input node. </dd></dl>

</div>
</div>
<a id="ab0280d09e3878357672dcfac7a3f9835" name="ab0280d09e3878357672dcfac7a3f9835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0280d09e3878357672dcfac7a3f9835">&#9670;&#160;</a></span>sumSomePairsFlow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::sumSomePairsFlow </td>
          <td>(</td>
          <td class="paramtype">set&lt; <a class="el" href="class_node.html">Node</a> * &gt;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>sumFlow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the sum of the maximum flows between all pairs of nodes in the input set. </p>
<p>Time Complexity: O(V E^2 * P^2), where E is the number of edges, V is the number of nodes in the graph and P is the number of nodes in the input set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodes</td><td>- Set of nodes to calculate the sum of the maximum flows between them. </td></tr>
    <tr><td class="paramname">sumFlow</td><td>- Pointer to the variable that will store the sum of the maximum flows. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>data_structures/<a class="el" href="_graph_8h_source.html">Graph.h</a></li>
<li>data_structures/Graph.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
